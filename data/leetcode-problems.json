{
  "metadata": {
    "totalProblems": 334,
    "lastUpdated": "2026-01-08",
    "categories": ["Array", "String", "Hash Table", "Dynamic Programming", "Math", "Sorting", "Greedy", "Depth-First Search", "Binary Search", "Tree", "Breadth-First Search", "Stack", "Graph", "Linked List", "Heap", "Two Pointers", "Sliding Window", "Backtracking", "Union Find", "Trie", "Monotonic Stack", "Bit Manipulation"]
  },
  "problems": [
    {
      "id": 1,
      "title": "Two Sum",
      "difficulty": "Easy",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers that add up to target.",
      "companies": ["Google", "Amazon", "Meta", "Microsoft", "Apple"],
      "patterns": ["Hash Map", "Two Pointers"],
      "leetcodeUrl": "https://leetcode.com/problems/two-sum/",
      "solutions": [
        {
          "approach": "Brute Force",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)",
          "bestFor": "Understanding only",
          "isOptimal": false,
          "code": "def twoSum(nums, target):\n    \"\"\"\n    Brute Force: Check all pairs\n    Time: O(n²) - nested loops\n    Space: O(1) - no extra space\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\n# ======== TEST CASES ========\nprint(\"=== Two Sum - Brute Force ===\")\n\n# Test 1: Basic\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = twoSum(nums, target)\nprint(f\"Input: {nums}, target={target}\")\nprint(f\"Output: {result}\")  # [0, 1]\nprint(f\"Check: nums[{result[0]}] + nums[{result[1]}] = {nums[result[0]]} + {nums[result[1]]} = {nums[result[0]] + nums[result[1]]}\")\nprint()\n\n# Test 2: Middle elements\nnums = [3, 2, 4]\ntarget = 6\nresult = twoSum(nums, target)\nprint(f\"Input: {nums}, target={target}\")\nprint(f\"Output: {result}\")  # [1, 2]",
          "expectedOutput": "=== Two Sum - Brute Force ===\nInput: [2, 7, 11, 15], target=9\nOutput: [0, 1]\nCheck: nums[0] + nums[1] = 2 + 7 = 9\n\nInput: [3, 2, 4], target=6\nOutput: [1, 2]"
        },
        {
          "approach": "Hash Map",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def twoSum(nums, target):\n    \"\"\"\n    Hash Map: O(1) lookup for complement\n    Time: O(n) - single pass\n    Space: O(n) - hash map storage\n    \n    Key insight: For each num, check if (target - num) exists\n    \"\"\"\n    seen = {}  # value -> index\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            return [seen[complement], i]\n        \n        seen[num] = i\n    \n    return []\n\n# ======== TEST CASES ========\nprint(\"=== Two Sum - Hash Map (Optimal) ===\")\n\n# Test 1\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = twoSum(nums, target)\nprint(f\"Input: {nums}, target={target}\")\nprint(f\"Output: {result}\")\nprint(f\"Verify: {nums[result[0]]} + {nums[result[1]]} = {target} ✓\")\nprint()\n\n# Test 2: Large array\nnums = [1, 5, 3, 7, 2, 8, 4, 6]\ntarget = 10\nresult = twoSum(nums, target)\nprint(f\"Input: {nums}, target={target}\")\nprint(f\"Output: {result}\")\nprint(f\"Verify: {nums[result[0]]} + {nums[result[1]]} = {target}\")",
          "expectedOutput": "=== Two Sum - Hash Map (Optimal) ===\nInput: [2, 7, 11, 15], target=9\nOutput: [0, 1]\nVerify: 2 + 7 = 9 ✓\n\nInput: [1, 5, 3, 7, 2, 8, 4, 6], target=10\nOutput: [1, 3]\nVerify: 5 + 7 = 10"
        },
        {
          "approach": "Two Pointers (Sorted)",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Pre-sorted array",
          "isOptimal": false,
          "code": "def twoSum(nums, target):\n    \"\"\"\n    Two Pointers: For sorted array or when we can sort\n    Time: O(n log n) for sort + O(n) for two pointers\n    Space: O(n) to preserve original indices\n    \n    Note: Use this when array is already sorted\n    \"\"\"\n    # Store (value, original_index) to preserve indices\n    indexed = [(num, i) for i, num in enumerate(nums)]\n    indexed.sort(key=lambda x: x[0])\n    \n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = indexed[left][0] + indexed[right][0]\n        \n        if current_sum == target:\n            return [indexed[left][1], indexed[right][1]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\n# For already sorted array (LeetCode 167)\ndef twoSumSorted(numbers, target):\n    \"\"\"Two pointers for sorted array - O(n) time, O(1) space\"\"\"\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        s = numbers[left] + numbers[right]\n        if s == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif s < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\n# ======== TEST CASES ========\nprint(\"=== Two Sum - Two Pointers ===\")\n\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = twoSum(nums, target)\nprint(f\"Unsorted: {nums}, target={target}\")\nprint(f\"Output: {result}\")",
          "expectedOutput": "=== Two Sum - Two Pointers ===\nUnsorted: [2, 7, 11, 15], target=9\nOutput: [0, 1]"
        }
      ]
    },
    {
      "id": 2,
      "title": "Add Two Numbers",
      "difficulty": "Medium",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order. Add the two numbers and return the sum as a linked list.",
      "companies": ["Amazon", "Microsoft", "Google", "Meta"],
      "patterns": ["Linked List", "Math"],
      "leetcodeUrl": "https://leetcode.com/problems/add-two-numbers/",
      "solutions": [
        {
          "approach": "Elementary Math with Carry",
          "timeComplexity": "O(max(m,n))",
          "spaceComplexity": "O(max(m,n))",
          "bestFor": "All cases",
          "isOptimal": true,
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    \"\"\"\n    Elementary Math: Add digit by digit with carry\n    Time: O(max(m, n)) - traverse both lists once\n    Space: O(max(m, n)) - new list for result\n    \n    Key insight: Use dummy head to simplify edge cases\n    \"\"\"\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n    \n    while l1 or l2 or carry:\n        # Get values (0 if list exhausted)\n        x = l1.val if l1 else 0\n        y = l2.val if l2 else 0\n        \n        # Calculate sum and carry\n        total = x + y + carry\n        carry = total // 10\n        current.next = ListNode(total % 10)\n        current = current.next\n        \n        # Move to next nodes\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    \n    return dummy.next\n\n# Helper to create list from array\ndef create_list(arr):\n    dummy = ListNode(0)\n    curr = dummy\n    for val in arr:\n        curr.next = ListNode(val)\n        curr = curr.next\n    return dummy.next\n\n# Helper to convert list to array\ndef list_to_arr(node):\n    arr = []\n    while node:\n        arr.append(node.val)\n        node = node.next\n    return arr\n\n# ======== TEST CASES ========\nprint(\"=== Add Two Numbers ===\")\n\n# Test 1: 342 + 465 = 807\nl1 = create_list([2, 4, 3])  # 342\nl2 = create_list([5, 6, 4])  # 465\nresult = addTwoNumbers(l1, l2)\nprint(f\"[2,4,3] + [5,6,4] = {list_to_arr(result)}\")  # [7,0,8] = 807\n\n# Test 2: 0 + 0 = 0\nl1 = create_list([0])\nl2 = create_list([0])\nresult = addTwoNumbers(l1, l2)\nprint(f\"[0] + [0] = {list_to_arr(result)}\")  # [0]\n\n# Test 3: Different lengths with carry\nl1 = create_list([9, 9, 9, 9, 9, 9, 9])\nl2 = create_list([9, 9, 9, 9])\nresult = addTwoNumbers(l1, l2)\nprint(f\"[9,9,9,9,9,9,9] + [9,9,9,9] = {list_to_arr(result)}\")",
          "expectedOutput": "=== Add Two Numbers ===\n[2,4,3] + [5,6,4] = [7, 0, 8]\n[0] + [0] = [0]\n[9,9,9,9,9,9,9] + [9,9,9,9] = [8, 9, 9, 9, 0, 0, 0, 1]"
        }
      ]
    },
    {
      "id": 3,
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "Medium",
      "description": "Find the length of the longest substring without repeating characters.",
      "companies": ["Amazon", "Google", "Microsoft", "Meta", "Apple"],
      "patterns": ["Sliding Window", "Hash Map"],
      "leetcodeUrl": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
      "solutions": [
        {
          "approach": "Brute Force",
          "timeComplexity": "O(n³)",
          "spaceComplexity": "O(min(n,m))",
          "bestFor": "Understanding only",
          "isOptimal": false,
          "code": "def lengthOfLongestSubstring(s):\n    \"\"\"\n    Brute Force: Check all substrings\n    Time: O(n³) - O(n²) substrings, O(n) to check each\n    Space: O(min(n, m)) - set for unique chars\n    \"\"\"\n    def all_unique(s, start, end):\n        chars = set()\n        for i in range(start, end):\n            if s[i] in chars:\n                return False\n            chars.add(s[i])\n        return True\n    \n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if all_unique(s, i, j):\n                max_len = max(max_len, j - i)\n    return max_len\n\n# Test\nprint(f\"Brute force 'abcabcbb': {lengthOfLongestSubstring('abcabcbb')}\")  # 3",
          "expectedOutput": "Brute force 'abcabcbb': 3"
        },
        {
          "approach": "Sliding Window + Set",
          "timeComplexity": "O(2n)",
          "spaceComplexity": "O(min(n,m))",
          "bestFor": "Easy to understand",
          "isOptimal": false,
          "code": "def lengthOfLongestSubstring(s):\n    \"\"\"\n    Sliding Window with Set\n    Time: O(2n) - each char visited at most twice\n    Space: O(min(n, m)) - set for window chars\n    \n    Pattern: Expand right, shrink left when duplicate\n    \"\"\"\n    char_set = set()\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        # Shrink window while duplicate exists\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        # Add current char and update max\n        char_set.add(s[right])\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Test\nprint(\"=== Sliding Window + Set ===\")\nfor s in [\"abcabcbb\", \"bbbbb\", \"pwwkew\", \"\"]:\n    print(f\"  '{s}' -> {lengthOfLongestSubstring(s)}\")",
          "expectedOutput": "=== Sliding Window + Set ===\n  'abcabcbb' -> 3\n  'bbbbb' -> 1\n  'pwwkew' -> 3\n  '' -> 0"
        },
        {
          "approach": "Optimized Sliding Window",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(min(n,m))",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def lengthOfLongestSubstring(s):\n    \"\"\"\n    Optimized Sliding Window with Hash Map\n    Time: O(n) - single pass\n    Space: O(min(n, m)) where m is charset size\n    \n    Key insight: Jump left pointer directly to position after duplicate\n    \"\"\"\n    char_index = {}  # char -> last seen index\n    left = 0\n    max_len = 0\n    \n    for right, char in enumerate(s):\n        # If char was seen and is within current window\n        if char in char_index and char_index[char] >= left:\n            # Jump past the duplicate\n            left = char_index[char] + 1\n        \n        # Update max length and store current index\n        max_len = max(max_len, right - left + 1)\n        char_index[char] = right\n    \n    return max_len\n\n# ======== TEST CASES ========\nprint(\"=== Longest Substring Without Repeating Characters ===\")\n\ntest_cases = [\n    (\"abcabcbb\", 3),  # \"abc\"\n    (\"bbbbb\", 1),     # \"b\"\n    (\"pwwkew\", 3),    # \"wke\" or \"kew\"\n    (\"\", 0),          # empty\n    (\"dvdf\", 3),      # \"vdf\"\n    (\"abba\", 2),      # \"ab\" or \"ba\"\n    (\"tmmzuxt\", 5),   # \"mzuxt\"\n]\n\nfor s, expected in test_cases:\n    result = lengthOfLongestSubstring(s)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f'  {status} \"{s}\" -> {result} (expected: {expected})')",
          "expectedOutput": "=== Longest Substring Without Repeating Characters ===\n  ✓ \"abcabcbb\" -> 3 (expected: 3)\n  ✓ \"bbbbb\" -> 1 (expected: 1)\n  ✓ \"pwwkew\" -> 3 (expected: 3)\n  ✓ \"\" -> 0 (expected: 0)\n  ✓ \"dvdf\" -> 3 (expected: 3)\n  ✓ \"abba\" -> 2 (expected: 2)\n  ✓ \"tmmzuxt\" -> 5 (expected: 5)"
        }
      ]
    },
    {
      "id": 4,
      "title": "Median of Two Sorted Arrays",
      "difficulty": "Hard",
      "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
      "companies": ["Google", "Amazon", "Microsoft", "Meta"],
      "patterns": ["Binary Search", "Divide and Conquer"],
      "leetcodeUrl": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
      "solutions": [
        {
          "approach": "Merge and Find",
          "timeComplexity": "O(m+n)",
          "spaceComplexity": "O(m+n)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "def findMedianSortedArrays(nums1, nums2):\n    \"\"\"\n    Merge and Find Median\n    Time: O(m+n) - merge both arrays\n    Space: O(m+n) - merged array\n    \n    Note: Not optimal but easy to understand\n    \"\"\"\n    merged = []\n    i = j = 0\n    \n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] <= nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    \n    merged.extend(nums1[i:])\n    merged.extend(nums2[j:])\n    \n    n = len(merged)\n    if n % 2 == 0:\n        return (merged[n//2 - 1] + merged[n//2]) / 2\n    return merged[n//2]\n\n# Test\nprint(f\"Merge approach [1,3] [2]: {findMedianSortedArrays([1,3], [2])}\")  # 2.0",
          "expectedOutput": "Merge approach [1,3] [2]: 2.0"
        },
        {
          "approach": "Binary Search",
          "timeComplexity": "O(log(min(m,n)))",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews (required)",
          "isOptimal": true,
          "code": "def findMedianSortedArrays(nums1, nums2):\n    \"\"\"\n    Binary Search: Partition both arrays\n    Time: O(log(min(m, n))) - binary search on smaller array\n    Space: O(1) - constant space\n    \n    Key insight: Find partition where left elements <= right elements\n    \"\"\"\n    # Ensure nums1 is smaller for O(log(min)) complexity\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    \n    while left <= right:\n        # Partition indices\n        i = (left + right) // 2\n        j = (m + n + 1) // 2 - i\n        \n        # Edge values (handle boundaries)\n        maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]\n        minRight1 = float('inf') if i == m else nums1[i]\n        maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]\n        minRight2 = float('inf') if j == n else nums2[j]\n        \n        # Check if partition is correct\n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            # Found correct partition\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2\n            return float(max(maxLeft1, maxLeft2))\n        elif maxLeft1 > minRight2:\n            # Too far right in nums1\n            right = i - 1\n        else:\n            # Too far left in nums1\n            left = i + 1\n    \n    return 0.0\n\n# ======== TEST CASES ========\nprint(\"=== Median of Two Sorted Arrays ===\")\n\ntest_cases = [\n    ([1, 3], [2], 2.0),\n    ([1, 2], [3, 4], 2.5),\n    ([0, 0], [0, 0], 0.0),\n    ([], [1], 1.0),\n    ([2], [], 2.0),\n]\n\nfor nums1, nums2, expected in test_cases:\n    result = findMedianSortedArrays(nums1, nums2)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"  {status} nums1={nums1}, nums2={nums2} -> {result}\")",
          "expectedOutput": "=== Median of Two Sorted Arrays ===\n  ✓ nums1=[1, 3], nums2=[2] -> 2.0\n  ✓ nums1=[1, 2], nums2=[3, 4] -> 2.5\n  ✓ nums1=[0, 0], nums2=[0, 0] -> 0.0\n  ✓ nums1=[], nums2=[1] -> 1.0\n  ✓ nums1=[2], nums2=[] -> 2.0"
        }
      ]
    },
    {
      "id": 5,
      "title": "Longest Palindromic Substring",
      "difficulty": "Medium",
      "description": "Given a string s, return the longest palindromic substring in s.",
      "companies": ["Amazon", "Microsoft", "Google", "Meta"],
      "patterns": ["Dynamic Programming", "Two Pointers"],
      "leetcodeUrl": "https://leetcode.com/problems/longest-palindromic-substring/",
      "solutions": [
        {
          "approach": "Expand Around Center",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def longestPalindrome(s):\n    \"\"\"\n    Expand Around Center\n    Time: O(n²) - n centers, expand up to n\n    Space: O(1) - only store indices\n    \n    Key insight: Every palindrome has a center (or two for even length)\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    def expand(left, right):\n        \"\"\"Expand from center while palindrome\"\"\"\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return left + 1, right - 1\n    \n    start, end = 0, 0\n    \n    for i in range(len(s)):\n        # Odd length palindrome (single center)\n        l1, r1 = expand(i, i)\n        # Even length palindrome (double center)\n        l2, r2 = expand(i, i + 1)\n        \n        # Update if longer found\n        if r1 - l1 > end - start:\n            start, end = l1, r1\n        if r2 - l2 > end - start:\n            start, end = l2, r2\n    \n    return s[start:end + 1]\n\n# ======== TEST CASES ========\nprint(\"=== Longest Palindromic Substring ===\")\n\ntest_cases = [\n    (\"babad\", [\"bab\", \"aba\"]),  # Either is valid\n    (\"cbbd\", [\"bb\"]),\n    (\"a\", [\"a\"]),\n    (\"ac\", [\"a\", \"c\"]),\n    (\"racecar\", [\"racecar\"]),\n]\n\nfor s, valid_answers in test_cases:\n    result = longestPalindrome(s)\n    status = \"✓\" if result in valid_answers else \"✗\"\n    print(f'  {status} \"{s}\" -> \"{result}\"')",
          "expectedOutput": "=== Longest Palindromic Substring ===\n  ✓ \"babad\" -> \"bab\"\n  ✓ \"cbbd\" -> \"bb\"\n  ✓ \"a\" -> \"a\"\n  ✓ \"ac\" -> \"a\"\n  ✓ \"racecar\" -> \"racecar\""
        },
        {
          "approach": "Dynamic Programming",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(n²)",
          "bestFor": "Learning DP",
          "isOptimal": false,
          "code": "def longestPalindrome(s):\n    \"\"\"\n    Dynamic Programming\n    Time: O(n²) - fill DP table\n    Space: O(n²) - DP table\n    \n    dp[i][j] = True if s[i:j+1] is palindrome\n    \"\"\"\n    n = len(s)\n    if n < 2:\n        return s\n    \n    dp = [[False] * n for _ in range(n)]\n    start, max_len = 0, 1\n    \n    # All single chars are palindromes\n    for i in range(n):\n        dp[i][i] = True\n    \n    # Check substrings of length 2 and more\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            if length == 2:\n                dp[i][j] = (s[i] == s[j])\n            else:\n                dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]\n            \n            if dp[i][j] and length > max_len:\n                start = i\n                max_len = length\n    \n    return s[start:start + max_len]\n\n# Test\nprint(f\"DP approach 'babad': {longestPalindrome('babad')}\")",
          "expectedOutput": "DP approach 'babad': bab"
        }
      ]
    },
    {
      "id": 11,
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "description": "Given n non-negative integers representing the heights of vertical lines, find two lines that together with the x-axis forms a container, that contains the most water.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Two Pointers", "Greedy"],
      "leetcodeUrl": "https://leetcode.com/problems/container-with-most-water/",
      "solutions": [
        {
          "approach": "Brute Force",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "def maxArea(height):\n    \"\"\"\n    Brute Force: Check all pairs\n    Time: O(n²) - all pairs\n    Space: O(1)\n    \"\"\"\n    max_water = 0\n    n = len(height)\n    for i in range(n):\n        for j in range(i + 1, n):\n            water = min(height[i], height[j]) * (j - i)\n            max_water = max(max_water, water)\n    return max_water\n\nprint(f\"Brute force [1,8,6,2,5,4,8,3,7]: {maxArea([1,8,6,2,5,4,8,3,7])}\")  # 49",
          "expectedOutput": "Brute force [1,8,6,2,5,4,8,3,7]: 49"
        },
        {
          "approach": "Two Pointers",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def maxArea(height):\n    \"\"\"\n    Two Pointers: Always move the shorter line\n    Time: O(n) - single pass\n    Space: O(1)\n    \n    Key insight: Moving the shorter line might find taller one,\n    but moving the taller line can only make container smaller\n    \"\"\"\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        # Calculate water for current container\n        width = right - left\n        h = min(height[left], height[right])\n        max_water = max(max_water, width * h)\n        \n        # Move pointer with smaller height\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water\n\n# ======== TEST CASES ========\nprint(\"=== Container With Most Water ===\")\n\ntest_cases = [\n    ([1, 8, 6, 2, 5, 4, 8, 3, 7], 49),\n    ([1, 1], 1),\n    ([4, 3, 2, 1, 4], 16),\n    ([1, 2, 1], 2),\n]\n\nfor height, expected in test_cases:\n    result = maxArea(height)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"  {status} {height} -> {result}\")",
          "expectedOutput": "=== Container With Most Water ===\n  ✓ [1, 8, 6, 2, 5, 4, 8, 3, 7] -> 49\n  ✓ [1, 1] -> 1\n  ✓ [4, 3, 2, 1, 4] -> 16\n  ✓ [1, 2, 1] -> 2"
        }
      ]
    },
    {
      "id": 15,
      "title": "3Sum",
      "difficulty": "Medium",
      "description": "Find all unique triplets in the array which gives the sum of zero.",
      "companies": ["Meta", "Amazon", "Google", "Microsoft", "Apple"],
      "patterns": ["Two Pointers", "Sorting"],
      "leetcodeUrl": "https://leetcode.com/problems/3sum/",
      "solutions": [
        {
          "approach": "Sort + Two Pointers",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def threeSum(nums):\n    \"\"\"\n    Sort + Two Pointers\n    Time: O(n²) - O(n log n) sort + O(n²) two pointers\n    Space: O(1) excluding output\n    \n    Key insight: Sort first, fix one element, use two pointers for rest\n    \"\"\"\n    nums.sort()\n    result = []\n    n = len(nums)\n    \n    for i in range(n - 2):\n        # Skip duplicates for first element\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        # Early termination: if smallest is positive, no solution\n        if nums[i] > 0:\n            break\n        \n        left, right = i + 1, n - 1\n        target = -nums[i]\n        \n        while left < right:\n            current_sum = nums[left] + nums[right]\n            \n            if current_sum == target:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # Skip duplicates\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return result\n\n# ======== TEST CASES ========\nprint(\"=== 3Sum ===\")\n\ntest_cases = [\n    ([-1, 0, 1, 2, -1, -4], [[-1, -1, 2], [-1, 0, 1]]),\n    ([0, 1, 1], []),\n    ([0, 0, 0], [[0, 0, 0]]),\n    ([-2, 0, 1, 1, 2], [[-2, 0, 2], [-2, 1, 1]]),\n]\n\nfor nums, expected in test_cases:\n    result = threeSum(nums[:])\n    print(f\"  Input: {nums}\")\n    print(f\"  Output: {result}\")\n    print()",
          "expectedOutput": "=== 3Sum ===\n  Input: [-1, 0, 1, 2, -1, -4]\n  Output: [[-1, -1, 2], [-1, 0, 1]]\n\n  Input: [0, 1, 1]\n  Output: []\n\n  Input: [0, 0, 0]\n  Output: [[0, 0, 0]]\n\n  Input: [-2, 0, 1, 1, 2]\n  Output: [[-2, 0, 2], [-2, 1, 1]]"
        }
      ]
    },
    {
      "id": 17,
      "title": "Letter Combinations of a Phone Number",
      "difficulty": "Medium",
      "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Backtracking", "Recursion"],
      "leetcodeUrl": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
      "solutions": [
        {
          "approach": "Backtracking",
          "timeComplexity": "O(4^n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def letterCombinations(digits):\n    \"\"\"\n    Backtracking: Build combinations recursively\n    Time: O(4^n * n) - 4^n combinations, n to build each\n    Space: O(n) - recursion depth\n    \n    Key insight: At each digit, branch to all possible letters\n    \"\"\"\n    if not digits:\n        return []\n    \n    phone_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    result = []\n    \n    def backtrack(index, current):\n        # Base case: built full combination\n        if index == len(digits):\n            result.append(current)\n            return\n        \n        # Try each letter for current digit\n        for letter in phone_map[digits[index]]:\n            backtrack(index + 1, current + letter)\n    \n    backtrack(0, \"\")\n    return result\n\n# ======== TEST CASES ========\nprint(\"=== Letter Combinations of Phone Number ===\")\n\ntest_cases = [\n    (\"23\", [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]),\n    (\"\", []),\n    (\"2\", [\"a\", \"b\", \"c\"]),\n]\n\nfor digits, expected in test_cases:\n    result = letterCombinations(digits)\n    status = \"✓\" if sorted(result) == sorted(expected) else \"✗\"\n    print(f'  {status} \"{digits}\" -> {result}')",
          "expectedOutput": "=== Letter Combinations of Phone Number ===\n  ✓ \"23\" -> ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n  ✓ \"\" -> []\n  ✓ \"2\" -> ['a', 'b', 'c']"
        }
      ]
    },
    {
      "id": 19,
      "title": "Remove Nth Node From End of List",
      "difficulty": "Medium",
      "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
      "companies": ["Amazon", "Google", "Meta"],
      "patterns": ["Linked List", "Two Pointers"],
      "leetcodeUrl": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
      "solutions": [
        {
          "approach": "Two Pass",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    \"\"\"\n    Two Pass: Count length, then remove\n    Time: O(n) - two passes\n    Space: O(1)\n    \"\"\"\n    # First pass: count length\n    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next\n    \n    # Edge case: remove head\n    if length == n:\n        return head.next\n    \n    # Second pass: find node before target\n    curr = head\n    for _ in range(length - n - 1):\n        curr = curr.next\n    \n    curr.next = curr.next.next\n    return head",
          "expectedOutput": ""
        },
        {
          "approach": "One Pass - Two Pointers",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    \"\"\"\n    One Pass: Two pointers with n gap\n    Time: O(n) - single pass\n    Space: O(1)\n    \n    Key insight: When fast reaches end, slow is at (n+1)th from end\n    \"\"\"\n    dummy = ListNode(0, head)\n    slow = fast = dummy\n    \n    # Move fast n+1 steps ahead\n    for _ in range(n + 1):\n        fast = fast.next\n    \n    # Move both until fast reaches end\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    \n    # Remove the nth node\n    slow.next = slow.next.next\n    return dummy.next\n\n# Helper functions\ndef create_list(arr):\n    dummy = ListNode(0)\n    curr = dummy\n    for val in arr:\n        curr.next = ListNode(val)\n        curr = curr.next\n    return dummy.next\n\ndef list_to_arr(node):\n    arr = []\n    while node:\n        arr.append(node.val)\n        node = node.next\n    return arr\n\n# ======== TEST CASES ========\nprint(\"=== Remove Nth Node From End ===\")\n\ntest_cases = [\n    ([1, 2, 3, 4, 5], 2, [1, 2, 3, 5]),\n    ([1], 1, []),\n    ([1, 2], 1, [1]),\n    ([1, 2], 2, [2]),\n]\n\nfor arr, n, expected in test_cases:\n    head = create_list(arr)\n    result = removeNthFromEnd(head, n)\n    result_arr = list_to_arr(result)\n    status = \"✓\" if result_arr == expected else \"✗\"\n    print(f\"  {status} {arr}, n={n} -> {result_arr}\")",
          "expectedOutput": "=== Remove Nth Node From End ===\n  ✓ [1, 2, 3, 4, 5], n=2 -> [1, 2, 3, 5]\n  ✓ [1], n=1 -> []\n  ✓ [1, 2], n=1 -> [1]\n  ✓ [1, 2], n=2 -> [2]"
        }
      ]
    },
    {
      "id": 20,
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft", "Apple"],
      "patterns": ["Stack", "String"],
      "leetcodeUrl": "https://leetcode.com/problems/valid-parentheses/",
      "solutions": [
        {
          "approach": "Stack",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "All cases",
          "isOptimal": true,
          "code": "def isValid(s):\n    \"\"\"\n    Stack: Push opening, pop and match closing\n    Time: O(n) - single pass\n    Space: O(n) - stack\n    \n    Key insight: Map closing to opening for easy matching\n    \"\"\"\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            # Closing bracket: check match\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            # Opening bracket: push to stack\n            stack.append(char)\n    \n    return len(stack) == 0\n\n# ======== TEST CASES ========\nprint(\"=== Valid Parentheses ===\")\n\ntest_cases = [\n    (\"()\", True),\n    (\"()[]{}\", True),\n    (\"(]\", False),\n    (\"([)]\", False),\n    (\"{[]}\", True),\n    (\"\", True),\n    (\"(((\", False),\n]\n\nfor s, expected in test_cases:\n    result = isValid(s)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f'  {status} \"{s}\" -> {result}')",
          "expectedOutput": "=== Valid Parentheses ===\n  ✓ \"()\" -> True\n  ✓ \"()[]{}\" -> True\n  ✓ \"(]\" -> False\n  ✓ \"([)]\" -> False\n  ✓ \"{[]}\" -> True\n  ✓ \"\" -> True\n  ✓ \"(((\" -> False"
        }
      ]
    },
    {
      "id": 21,
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "description": "Merge two sorted linked lists and return it as a sorted list.",
      "companies": ["Amazon", "Microsoft", "Google", "Meta"],
      "patterns": ["Linked List", "Recursion"],
      "leetcodeUrl": "https://leetcode.com/problems/merge-two-sorted-lists/",
      "solutions": [
        {
          "approach": "Iterative",
          "timeComplexity": "O(n+m)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(list1, list2):\n    \"\"\"\n    Iterative: Use dummy head, compare and link\n    Time: O(n + m) - visit each node once\n    Space: O(1) - only pointers\n    \n    Key insight: Dummy head simplifies edge cases\n    \"\"\"\n    dummy = ListNode(0)\n    current = dummy\n    \n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n    \n    # Attach remaining nodes\n    current.next = list1 or list2\n    \n    return dummy.next\n\n# Helper functions\ndef create_list(arr):\n    dummy = ListNode(0)\n    curr = dummy\n    for val in arr:\n        curr.next = ListNode(val)\n        curr = curr.next\n    return dummy.next\n\ndef list_to_arr(node):\n    arr = []\n    while node:\n        arr.append(node.val)\n        node = node.next\n    return arr\n\n# ======== TEST CASES ========\nprint(\"=== Merge Two Sorted Lists ===\")\n\ntest_cases = [\n    ([1, 2, 4], [1, 3, 4], [1, 1, 2, 3, 4, 4]),\n    ([], [], []),\n    ([], [0], [0]),\n]\n\nfor arr1, arr2, expected in test_cases:\n    l1 = create_list(arr1)\n    l2 = create_list(arr2)\n    result = mergeTwoLists(l1, l2)\n    result_arr = list_to_arr(result)\n    status = \"✓\" if result_arr == expected else \"✗\"\n    print(f\"  {status} {arr1} + {arr2} -> {result_arr}\")",
          "expectedOutput": "=== Merge Two Sorted Lists ===\n  ✓ [1, 2, 4] + [1, 3, 4] -> [1, 1, 2, 3, 4, 4]\n  ✓ [] + [] -> []\n  ✓ [] + [0] -> [0]"
        },
        {
          "approach": "Recursive",
          "timeComplexity": "O(n+m)",
          "spaceComplexity": "O(n+m)",
          "bestFor": "Elegant code",
          "isOptimal": false,
          "code": "def mergeTwoLists(list1, list2):\n    \"\"\"\n    Recursive: Smaller node links to merged rest\n    Time: O(n + m)\n    Space: O(n + m) - recursion stack\n    \"\"\"\n    if not list1:\n        return list2\n    if not list2:\n        return list1\n    \n    if list1.val <= list2.val:\n        list1.next = mergeTwoLists(list1.next, list2)\n        return list1\n    else:\n        list2.next = mergeTwoLists(list1, list2.next)\n        return list2",
          "expectedOutput": ""
        }
      ]
    },
    {
      "id": 22,
      "title": "Generate Parentheses",
      "difficulty": "Medium",
      "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Backtracking", "Recursion"],
      "leetcodeUrl": "https://leetcode.com/problems/generate-parentheses/",
      "solutions": [
        {
          "approach": "Backtracking",
          "timeComplexity": "O(4^n/√n)",
          "spaceComplexity": "O(n)",
          "bestFor": "All cases",
          "isOptimal": true,
          "code": "def generateParenthesis(n):\n    \"\"\"\n    Backtracking: Track open/close counts\n    Time: O(4^n / √n) - nth Catalan number\n    Space: O(n) - recursion depth\n    \n    Key insight: Can add '(' if open < n, ')' if close < open\n    \"\"\"\n    result = []\n    \n    def backtrack(current, open_count, close_count):\n        # Base case: built valid combination\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        # Add open paren if available\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        \n        # Add close paren if valid (close < open)\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result\n\n# ======== TEST CASES ========\nprint(\"=== Generate Parentheses ===\")\n\ntest_cases = [\n    (1, [\"()\"]),\n    (2, [\"(())\", \"()()\"]),\n    (3, [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]),\n]\n\nfor n, expected in test_cases:\n    result = generateParenthesis(n)\n    status = \"✓\" if sorted(result) == sorted(expected) else \"✗\"\n    print(f\"  {status} n={n} -> {result}\")",
          "expectedOutput": "=== Generate Parentheses ===\n  ✓ n=1 -> ['()']\n  ✓ n=2 -> ['(())', '()()']\n  ✓ n=3 -> ['((()))', '(()())', '(())()', '()(())', '()()()']"
        }
      ]
    },
    {
      "id": 23,
      "title": "Merge k Sorted Lists",
      "difficulty": "Hard",
      "description": "Merge k sorted linked lists and return it as one sorted list.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Linked List", "Heap", "Divide and Conquer"],
      "leetcodeUrl": "https://leetcode.com/problems/merge-k-sorted-lists/",
      "solutions": [
        {
          "approach": "Min Heap",
          "timeComplexity": "O(n log k)",
          "spaceComplexity": "O(k)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    \n    def __lt__(self, other):\n        return self.val < other.val\n\ndef mergeKLists(lists):\n    \"\"\"\n    Min Heap: Always extract minimum from k lists\n    Time: O(n log k) - n nodes, log k for heap ops\n    Space: O(k) - heap size\n    \n    Key insight: Heap maintains smallest of k current nodes\n    \"\"\"\n    heap = []\n    \n    # Add first node from each list\n    for lst in lists:\n        if lst:\n            heapq.heappush(heap, lst)\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        # Extract minimum\n        node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        # Add next from same list\n        if node.next:\n            heapq.heappush(heap, node.next)\n    \n    return dummy.next\n\n# Helper functions\ndef create_list(arr):\n    if not arr:\n        return None\n    dummy = ListNode(0)\n    curr = dummy\n    for val in arr:\n        curr.next = ListNode(val)\n        curr = curr.next\n    return dummy.next\n\ndef list_to_arr(node):\n    arr = []\n    while node:\n        arr.append(node.val)\n        node = node.next\n    return arr\n\n# ======== TEST CASES ========\nprint(\"=== Merge k Sorted Lists ===\")\n\nlists = [\n    create_list([1, 4, 5]),\n    create_list([1, 3, 4]),\n    create_list([2, 6])\n]\nresult = mergeKLists(lists)\nprint(f\"  [[1,4,5],[1,3,4],[2,6]] -> {list_to_arr(result)}\")",
          "expectedOutput": "=== Merge k Sorted Lists ===\n  [[1,4,5],[1,3,4],[2,6]] -> [1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "approach": "Divide and Conquer",
          "timeComplexity": "O(n log k)",
          "spaceComplexity": "O(log k)",
          "bestFor": "Elegant",
          "isOptimal": true,
          "code": "def mergeKLists(lists):\n    \"\"\"\n    Divide and Conquer: Pair-wise merge\n    Time: O(n log k) - log k levels, n nodes per level\n    Space: O(log k) - recursion depth\n    \"\"\"\n    if not lists:\n        return None\n    \n    def merge2Lists(l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next\n    \n    # Pair-wise merge until one list remains\n    while len(lists) > 1:\n        merged = []\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 < len(lists) else None\n            merged.append(merge2Lists(l1, l2))\n        lists = merged\n    \n    return lists[0]",
          "expectedOutput": ""
        }
      ]
    },
    {
      "id": 33,
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "description": "Search for a target value in a rotated sorted array.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Binary Search"],
      "leetcodeUrl": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
      "solutions": [
        {
          "approach": "Modified Binary Search",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def search(nums, target):\n    \"\"\"\n    Modified Binary Search: Identify sorted half\n    Time: O(log n) - binary search\n    Space: O(1)\n    \n    Key insight: One half is always sorted, use it to determine direction\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # Right half is sorted\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1\n\n# ======== TEST CASES ========\nprint(\"=== Search in Rotated Sorted Array ===\")\n\ntest_cases = [\n    ([4, 5, 6, 7, 0, 1, 2], 0, 4),\n    ([4, 5, 6, 7, 0, 1, 2], 3, -1),\n    ([1], 0, -1),\n    ([1], 1, 0),\n    ([3, 1], 1, 1),\n]\n\nfor nums, target, expected in test_cases:\n    result = search(nums, target)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"  {status} {nums}, target={target} -> {result}\")",
          "expectedOutput": "=== Search in Rotated Sorted Array ===\n  ✓ [4, 5, 6, 7, 0, 1, 2], target=0 -> 4\n  ✓ [4, 5, 6, 7, 0, 1, 2], target=3 -> -1\n  ✓ [1], target=0 -> -1\n  ✓ [1], target=1 -> 0\n  ✓ [3, 1], target=1 -> 1"
        }
      ]
    },
    {
      "id": 42,
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "description": "Given n non-negative integers representing an elevation map, compute how much water it can trap after raining.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft", "Apple"],
      "patterns": ["Two Pointers", "Stack", "Dynamic Programming"],
      "leetcodeUrl": "https://leetcode.com/problems/trapping-rain-water/",
      "solutions": [
        {
          "approach": "Dynamic Programming",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "def trap(height):\n    \"\"\"\n    DP: Pre-compute left and right max heights\n    Time: O(n) - three passes\n    Space: O(n) - two arrays\n    \n    Water at i = min(leftMax[i], rightMax[i]) - height[i]\n    \"\"\"\n    if not height:\n        return 0\n    \n    n = len(height)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    # Fill left max\n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], height[i])\n    \n    # Fill right max\n    right_max[n-1] = height[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], height[i])\n    \n    # Calculate water\n    water = 0\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - height[i]\n    \n    return water\n\nprint(f\"DP approach: {trap([0,1,0,2,1,0,1,3,2,1,2,1])}\")  # 6",
          "expectedOutput": "DP approach: 6"
        },
        {
          "approach": "Two Pointers",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def trap(height):\n    \"\"\"\n    Two Pointers: Process from both ends\n    Time: O(n) - single pass\n    Space: O(1)\n    \n    Key insight: Water at position depends on smaller of two maxes,\n    so process side with smaller max first\n    \"\"\"\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water\n\n# ======== TEST CASES ========\nprint(\"=== Trapping Rain Water ===\")\n\ntest_cases = [\n    ([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], 6),\n    ([4, 2, 0, 3, 2, 5], 9),\n    ([1, 2, 3, 4, 5], 0),\n    ([5, 4, 3, 2, 1], 0),\n]\n\nfor height, expected in test_cases:\n    result = trap(height)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"  {status} {height} -> {result}\")",
          "expectedOutput": "=== Trapping Rain Water ===\n  ✓ [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] -> 6\n  ✓ [4, 2, 0, 3, 2, 5] -> 9\n  ✓ [1, 2, 3, 4, 5] -> 0\n  ✓ [5, 4, 3, 2, 1] -> 0"
        },
        {
          "approach": "Monotonic Stack",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Stack patterns",
          "isOptimal": false,
          "code": "def trap(height):\n    \"\"\"\n    Monotonic Stack: Process horizontal layers\n    Time: O(n) - each index pushed/popped once\n    Space: O(n) - stack\n    \n    Key insight: Find boundaries for each \"pool\"\n    \"\"\"\n    stack = []  # indices of decreasing heights\n    water = 0\n    \n    for i, h in enumerate(height):\n        while stack and height[stack[-1]] < h:\n            bottom = stack.pop()\n            if not stack:\n                break\n            \n            width = i - stack[-1] - 1\n            bounded_height = min(h, height[stack[-1]]) - height[bottom]\n            water += width * bounded_height\n        \n        stack.append(i)\n    \n    return water\n\nprint(f\"Stack approach: {trap([0,1,0,2,1,0,1,3,2,1,2,1])}\")  # 6",
          "expectedOutput": "Stack approach: 6"
        }
      ]
    },
    {
      "id": 46,
      "title": "Permutations",
      "difficulty": "Medium",
      "description": "Given an array nums of distinct integers, return all the possible permutations.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Backtracking"],
      "leetcodeUrl": "https://leetcode.com/problems/permutations/",
      "solutions": [
        {
          "approach": "Backtracking with Used Set",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def permute(nums):\n    \"\"\"\n    Backtracking: Build permutations by choosing unused elements\n    Time: O(n!) - n! permutations\n    Space: O(n) - recursion depth and current permutation\n    \n    Pattern: Pick or skip with tracking of used elements\n    \"\"\"\n    result = []\n    \n    def backtrack(current, used):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for i, num in enumerate(nums):\n            if i in used:\n                continue\n            \n            current.append(num)\n            used.add(i)\n            backtrack(current, used)\n            current.pop()\n            used.remove(i)\n    \n    backtrack([], set())\n    return result\n\n# ======== TEST CASES ========\nprint(\"=== Permutations ===\")\n\ntest_cases = [\n    ([1, 2, 3], [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]),\n    ([0, 1], [[0,1],[1,0]]),\n    ([1], [[1]]),\n]\n\nfor nums, expected in test_cases:\n    result = permute(nums)\n    print(f\"  Input: {nums}\")\n    print(f\"  Output: {result}\")\n    print(f\"  Count: {len(result)} permutations\")\n    print()",
          "expectedOutput": "=== Permutations ===\n  Input: [1, 2, 3]\n  Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n  Count: 6 permutations\n\n  Input: [0, 1]\n  Output: [[0, 1], [1, 0]]\n  Count: 2 permutations\n\n  Input: [1]\n  Output: [[1]]\n  Count: 1 permutations"
        }
      ]
    },
    {
      "id": 49,
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "description": "Given an array of strings, group the anagrams together.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Hash Map", "String"],
      "leetcodeUrl": "https://leetcode.com/problems/group-anagrams/",
      "solutions": [
        {
          "approach": "Sorted String Key",
          "timeComplexity": "O(n * k log k)",
          "spaceComplexity": "O(n * k)",
          "bestFor": "Simple implementation",
          "isOptimal": false,
          "code": "from collections import defaultdict\n\ndef groupAnagrams(strs):\n    \"\"\"\n    Sorted Key: Anagrams have same sorted form\n    Time: O(n * k log k) - n strings, k max length, sort each\n    Space: O(n * k) - store all strings\n    \"\"\"\n    groups = defaultdict(list)\n    \n    for s in strs:\n        # Sorted string as key\n        key = ''.join(sorted(s))\n        groups[key].append(s)\n    \n    return list(groups.values())\n\nprint(\"Sorted key approach:\")\nresult = groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\nfor group in result:\n    print(f\"  {group}\")",
          "expectedOutput": "Sorted key approach:\n  ['eat', 'tea', 'ate']\n  ['tan', 'nat']\n  ['bat']"
        },
        {
          "approach": "Character Count Key",
          "timeComplexity": "O(n * k)",
          "spaceComplexity": "O(n * k)",
          "bestFor": "Better time complexity",
          "isOptimal": true,
          "code": "from collections import defaultdict\n\ndef groupAnagrams(strs):\n    \"\"\"\n    Count Key: Use char frequency as key\n    Time: O(n * k) - n strings, k max length\n    Space: O(n * k)\n    \n    Key insight: Char count tuple is unique for anagrams\n    \"\"\"\n    groups = defaultdict(list)\n    \n    for s in strs:\n        # Count frequency of each character\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        \n        # Use tuple of counts as key (hashable)\n        key = tuple(count)\n        groups[key].append(s)\n    \n    return list(groups.values())\n\n# ======== TEST CASES ========\nprint(\"=== Group Anagrams ===\")\n\ntest_cases = [\n    [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n    [\"\"],\n    [\"a\"],\n]\n\nfor strs in test_cases:\n    result = groupAnagrams(strs)\n    print(f\"  Input: {strs}\")\n    print(f\"  Output: {result}\")\n    print()",
          "expectedOutput": "=== Group Anagrams ===\n  Input: ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n  Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n\n  Input: ['']\n  Output: [['']]\n\n  Input: ['a']\n  Output: [['a']]"
        }
      ]
    },
    {
      "id": 53,
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "description": "Find the contiguous subarray with the largest sum.",
      "companies": ["Amazon", "Google", "Microsoft", "Meta", "Apple"],
      "patterns": ["Dynamic Programming", "Divide and Conquer"],
      "leetcodeUrl": "https://leetcode.com/problems/maximum-subarray/",
      "solutions": [
        {
          "approach": "Kadane's Algorithm",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "All cases",
          "isOptimal": true,
          "code": "def maxSubArray(nums):\n    \"\"\"\n    Kadane's Algorithm\n    Time: O(n) - single pass\n    Space: O(1)\n    \n    Key insight: At each position, decide to extend or start new subarray\n    current_sum = max(num, current_sum + num)\n    \"\"\"\n    if not nums:\n        return 0\n    \n    current_sum = max_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Either extend current subarray or start new\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n# ======== TEST CASES ========\nprint(\"=== Maximum Subarray ===\")\n\ntest_cases = [\n    ([-2, 1, -3, 4, -1, 2, 1, -5, 4], 6),  # [4,-1,2,1]\n    ([1], 1),\n    ([5, 4, -1, 7, 8], 23),\n    ([-1], -1),\n    ([-2, -1], -1),\n]\n\nfor nums, expected in test_cases:\n    result = maxSubArray(nums)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"  {status} {nums} -> {result}\")",
          "expectedOutput": "=== Maximum Subarray ===\n  ✓ [-2, 1, -3, 4, -1, 2, 1, -5, 4] -> 6\n  ✓ [1] -> 1\n  ✓ [5, 4, -1, 7, 8] -> 23\n  ✓ [-1] -> -1\n  ✓ [-2, -1] -> -1"
        }
      ]
    },
    {
      "id": 56,
      "title": "Merge Intervals",
      "difficulty": "Medium",
      "description": "Given an array of intervals, merge all overlapping intervals.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft", "Apple"],
      "patterns": ["Sorting", "Intervals"],
      "leetcodeUrl": "https://leetcode.com/problems/merge-intervals/",
      "solutions": [
        {
          "approach": "Sort and Merge",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "bestFor": "All cases",
          "isOptimal": true,
          "code": "def merge(intervals):\n    \"\"\"\n    Sort + Merge: Process intervals in order\n    Time: O(n log n) - sorting dominates\n    Space: O(n) - result array\n    \n    Key insight: After sorting by start, only need to check overlap with last\n    \"\"\"\n    if not intervals:\n        return []\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last = result[-1]\n        \n        # Check if overlapping\n        if current[0] <= last[1]:\n            # Merge by extending end\n            last[1] = max(last[1], current[1])\n        else:\n            # No overlap, add new interval\n            result.append(current)\n    \n    return result\n\n# ======== TEST CASES ========\nprint(\"=== Merge Intervals ===\")\n\ntest_cases = [\n    ([[1,3],[2,6],[8,10],[15,18]], [[1,6],[8,10],[15,18]]),\n    ([[1,4],[4,5]], [[1,5]]),\n    ([[1,4],[0,4]], [[0,4]]),\n    ([[1,4],[2,3]], [[1,4]]),\n]\n\nfor intervals, expected in test_cases:\n    result = merge([i[:] for i in intervals])\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"  {status} {intervals} -> {result}\")",
          "expectedOutput": "=== Merge Intervals ===\n  ✓ [[1, 3], [2, 6], [8, 10], [15, 18]] -> [[1, 6], [8, 10], [15, 18]]\n  ✓ [[1, 4], [4, 5]] -> [[1, 5]]\n  ✓ [[1, 4], [0, 4]] -> [[0, 4]]\n  ✓ [[1, 4], [2, 3]] -> [[1, 4]]"
        }
      ]
    },
    {
      "id": 70,
      "title": "Climbing Stairs",
      "difficulty": "Easy",
      "description": "You can climb 1 or 2 steps at a time. How many distinct ways can you climb to the top?",
      "companies": ["Amazon", "Google", "Microsoft"],
      "patterns": ["Dynamic Programming", "Fibonacci"],
      "leetcodeUrl": "https://leetcode.com/problems/climbing-stairs/",
      "solutions": [
        {
          "approach": "Dynamic Programming",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "All cases",
          "isOptimal": true,
          "code": "def climbStairs(n):\n    \"\"\"\n    Fibonacci Pattern: dp[i] = dp[i-1] + dp[i-2]\n    Time: O(n)\n    Space: O(1) - only track last two values\n    \n    Key insight: This is Fibonacci! To reach step n, you came from n-1 or n-2\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n    \n    for _ in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n# ======== TEST CASES ========\nprint(\"=== Climbing Stairs ===\")\n\ntest_cases = [\n    (1, 1),\n    (2, 2),\n    (3, 3),\n    (4, 5),\n    (5, 8),\n    (10, 89),\n]\n\nfor n, expected in test_cases:\n    result = climbStairs(n)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"  {status} n={n} -> {result}\")",
          "expectedOutput": "=== Climbing Stairs ===\n  ✓ n=1 -> 1\n  ✓ n=2 -> 2\n  ✓ n=3 -> 3\n  ✓ n=4 -> 5\n  ✓ n=5 -> 8\n  ✓ n=10 -> 89"
        }
      ]
    },
    {
      "id": 76,
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "description": "Find the minimum window substring of s such that every character in t is included in the window.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Sliding Window", "Hash Map"],
      "leetcodeUrl": "https://leetcode.com/problems/minimum-window-substring/",
      "solutions": [
        {
          "approach": "Sliding Window",
          "timeComplexity": "O(m+n)",
          "spaceComplexity": "O(m+n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "from collections import Counter\n\ndef minWindow(s, t):\n    \"\"\"\n    Sliding Window: Expand right to include, shrink left to minimize\n    Time: O(m + n) - each char visited at most twice\n    Space: O(m + n) - counter for both strings\n    \n    Key insight: Track how many unique chars are satisfied\n    \"\"\"\n    if not s or not t or len(s) < len(t):\n        return \"\"\n    \n    # Count required characters\n    t_count = Counter(t)\n    required = len(t_count)\n    formed = 0\n    window_counts = {}\n    \n    left = 0\n    ans = float(\"inf\"), None, None\n    \n    for right, c in enumerate(s):\n        # Add character to window\n        window_counts[c] = window_counts.get(c, 0) + 1\n        \n        # Check if this char satisfies requirement\n        if c in t_count and window_counts[c] == t_count[c]:\n            formed += 1\n        \n        # Try to shrink window\n        while left <= right and formed == required:\n            # Update answer if smaller window found\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            # Remove leftmost char\n            char = s[left]\n            window_counts[char] -= 1\n            if char in t_count and window_counts[char] < t_count[char]:\n                formed -= 1\n            left += 1\n    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2]+1]\n\n# ======== TEST CASES ========\nprint(\"=== Minimum Window Substring ===\")\n\ntest_cases = [\n    (\"ADOBECODEBANC\", \"ABC\", \"BANC\"),\n    (\"a\", \"a\", \"a\"),\n    (\"a\", \"aa\", \"\"),\n]\n\nfor s, t, expected in test_cases:\n    result = minWindow(s, t)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f'  {status} s=\"{s}\", t=\"{t}\" -> \"{result}\"')",
          "expectedOutput": "=== Minimum Window Substring ===\n  ✓ s=\"ADOBECODEBANC\", t=\"ABC\" -> \"BANC\"\n  ✓ s=\"a\", t=\"a\" -> \"a\"\n  ✓ s=\"a\", t=\"aa\" -> \"\""
        }
      ]
    },
    {
      "id": 78,
      "title": "Subsets",
      "difficulty": "Medium",
      "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Backtracking", "Bit Manipulation"],
      "leetcodeUrl": "https://leetcode.com/problems/subsets/",
      "solutions": [
        {
          "approach": "Backtracking",
          "timeComplexity": "O(n * 2^n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def subsets(nums):\n    \"\"\"\n    Backtracking: Include or exclude each element\n    Time: O(n * 2^n) - 2^n subsets, O(n) to copy each\n    Space: O(n) - recursion depth\n    \n    Key insight: At each position, choose to include or not\n    \"\"\"\n    result = []\n    \n    def backtrack(start, current):\n        # Add copy of current subset\n        result.append(current[:])\n        \n        # Try adding each remaining element\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(0, [])\n    return result\n\n# ======== TEST CASES ========\nprint(\"=== Subsets ===\")\n\ntest_cases = [\n    ([1, 2, 3], [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]),\n    ([0], [[], [0]]),\n    ([], [[]]),\n]\n\nfor nums, expected in test_cases:\n    result = subsets(nums)\n    print(f\"  Input: {nums}\")\n    print(f\"  Output: {result}\")\n    print(f\"  Count: {len(result)} subsets\")\n    print()",
          "expectedOutput": "=== Subsets ===\n  Input: [1, 2, 3]\n  Output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n  Count: 8 subsets\n\n  Input: [0]\n  Output: [[], [0]]\n  Count: 2 subsets\n\n  Input: []\n  Output: [[]]\n  Count: 1 subsets"
        },
        {
          "approach": "Iterative",
          "timeComplexity": "O(n * 2^n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Simple implementation",
          "isOptimal": true,
          "code": "def subsets(nums):\n    \"\"\"\n    Iterative: Start with empty, add each num to all existing\n    Time: O(n * 2^n)\n    Space: O(1) extra (excluding result)\n    \n    Key insight: Each new number doubles the subsets\n    \"\"\"\n    result = [[]]\n    \n    for num in nums:\n        # Add num to copy of each existing subset\n        result += [subset + [num] for subset in result]\n    \n    return result\n\nprint(f\"Iterative: {subsets([1, 2, 3])}\")",
          "expectedOutput": "Iterative: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]"
        },
        {
          "approach": "Bit Manipulation",
          "timeComplexity": "O(n * 2^n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Understanding binary",
          "isOptimal": true,
          "code": "def subsets(nums):\n    \"\"\"\n    Bit Manipulation: Each number 0 to 2^n-1 represents a subset\n    Time: O(n * 2^n)\n    Space: O(1) extra\n    \n    Key insight: Bit i represents whether to include nums[i]\n    \"\"\"\n    n = len(nums)\n    result = []\n    \n    for mask in range(1 << n):  # 0 to 2^n - 1\n        subset = []\n        for i in range(n):\n            if mask & (1 << i):  # Check if bit i is set\n                subset.append(nums[i])\n        result.append(subset)\n    \n    return result\n\nprint(f\"Bit manipulation: {subsets([1, 2, 3])}\")",
          "expectedOutput": "Bit manipulation: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]"
        }
      ]
    },
    {
      "id": 79,
      "title": "Word Search",
      "difficulty": "Medium",
      "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Backtracking", "DFS"],
      "leetcodeUrl": "https://leetcode.com/problems/word-search/",
      "solutions": [
        {
          "approach": "DFS Backtracking",
          "timeComplexity": "O(m * n * 4^L)",
          "spaceComplexity": "O(L)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def exist(board, word):\n    \"\"\"\n    DFS Backtracking: Search from each cell\n    Time: O(m * n * 4^L) - L is word length, 4 directions\n    Space: O(L) - recursion depth\n    \n    Key insight: Mark visited cells, backtrack by unmarking\n    \"\"\"\n    if not board or not board[0]:\n        return False\n    \n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, index):\n        # Found complete word\n        if index == len(word):\n            return True\n        \n        # Boundary and character check\n        if (r < 0 or r >= rows or c < 0 or c >= cols or\n            board[r][c] != word[index]):\n            return False\n        \n        # Mark as visited\n        temp = board[r][c]\n        board[r][c] = '#'\n        \n        # Explore all 4 directions\n        found = (dfs(r + 1, c, index + 1) or\n                 dfs(r - 1, c, index + 1) or\n                 dfs(r, c + 1, index + 1) or\n                 dfs(r, c - 1, index + 1))\n        \n        # Restore cell (backtrack)\n        board[r][c] = temp\n        return found\n    \n    # Try starting from each cell\n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0):\n                return True\n    \n    return False\n\n# ======== TEST CASES ========\nprint(\"=== Word Search ===\")\n\nboard1 = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\nprint(f\"  'ABCCED': {exist([row[:] for row in board1], 'ABCCED')}\")  # True\nprint(f\"  'SEE': {exist([row[:] for row in board1], 'SEE')}\")  # True\nprint(f\"  'ABCB': {exist([row[:] for row in board1], 'ABCB')}\")  # False",
          "expectedOutput": "=== Word Search ===\n  'ABCCED': True\n  'SEE': True\n  'ABCB': False"
        }
      ]
    },
    {
      "id": 98,
      "title": "Validate Binary Search Tree",
      "difficulty": "Medium",
      "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Tree", "DFS", "Recursion"],
      "leetcodeUrl": "https://leetcode.com/problems/validate-binary-search-tree/",
      "solutions": [
        {
          "approach": "Recursive with Range",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBST(root):\n    \"\"\"\n    Recursive: Pass valid range to each node\n    Time: O(n) - visit each node once\n    Space: O(h) - recursion depth (height of tree)\n    \n    Key insight: Each node must be within (min, max) range\n    \"\"\"\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        # Check current node value is within range\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        # Left subtree must be < node.val\n        # Right subtree must be > node.val\n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))\n\n# ======== TEST CASES ========\nprint(\"=== Validate Binary Search Tree ===\")\n\n# Test 1: Valid BST [2, 1, 3]\nroot1 = TreeNode(2, TreeNode(1), TreeNode(3))\nprint(f\"  [2, 1, 3]: {isValidBST(root1)}\")  # True\n\n# Test 2: Invalid BST [5, 1, 4, null, null, 3, 6]\nroot2 = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))\nprint(f\"  [5, 1, 4, null, null, 3, 6]: {isValidBST(root2)}\")  # False\n\n# Test 3: Invalid BST [5, 4, 6, null, null, 3, 7]\nroot3 = TreeNode(5, TreeNode(4), TreeNode(6, TreeNode(3), TreeNode(7)))\nprint(f\"  [5, 4, 6, null, null, 3, 7]: {isValidBST(root3)}\")  # False",
          "expectedOutput": "=== Validate Binary Search Tree ===\n  [2, 1, 3]: True\n  [5, 1, 4, null, null, 3, 6]: False\n  [5, 4, 6, null, null, 3, 7]: False"
        },
        {
          "approach": "Inorder Traversal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "bestFor": "Elegant",
          "isOptimal": true,
          "code": "def isValidBST(root):\n    \"\"\"\n    Inorder: BST inorder traversal gives sorted sequence\n    Time: O(n)\n    Space: O(h)\n    \n    Key insight: Previous value must always be less than current\n    \"\"\"\n    prev = [float('-inf')]  # Use list to allow modification in nested function\n    \n    def inorder(node):\n        if not node:\n            return True\n        \n        # Check left subtree\n        if not inorder(node.left):\n            return False\n        \n        # Check current node against previous\n        if node.val <= prev[0]:\n            return False\n        prev[0] = node.val\n        \n        # Check right subtree\n        return inorder(node.right)\n    \n    return inorder(root)\n\nprint(\"Inorder approach works similarly\")",
          "expectedOutput": "Inorder approach works similarly"
        }
      ]
    },
    {
      "id": 102,
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "Medium",
      "description": "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Tree", "BFS"],
      "leetcodeUrl": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
      "solutions": [
        {
          "approach": "BFS with Queue",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    \"\"\"\n    BFS: Process level by level using queue\n    Time: O(n) - visit each node once\n    Space: O(n) - queue can hold up to n/2 nodes\n    \n    Key insight: Process all nodes at current level before moving to next\n    \"\"\"\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        # Process all nodes at current level\n        for _ in range(level_size):\n            node = queue.popleft()\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result\n\n# ======== TEST CASES ========\nprint(\"=== Binary Tree Level Order Traversal ===\")\n\n# Test 1: [3, 9, 20, null, null, 15, 7]\nroot1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\nprint(f\"  Tree [3,9,20,null,null,15,7]: {levelOrder(root1)}\")\n\n# Test 2: [1]\nroot2 = TreeNode(1)\nprint(f\"  Tree [1]: {levelOrder(root2)}\")\n\n# Test 3: Empty\nprint(f\"  Empty tree: {levelOrder(None)}\")",
          "expectedOutput": "=== Binary Tree Level Order Traversal ===\n  Tree [3,9,20,null,null,15,7]: [[3], [9, 20], [15, 7]]\n  Tree [1]: [[1]]\n  Empty tree: []"
        },
        {
          "approach": "DFS with Level Tracking",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "bestFor": "Recursive approach",
          "isOptimal": true,
          "code": "def levelOrder(root):\n    \"\"\"\n    DFS: Track level and add to corresponding list\n    Time: O(n)\n    Space: O(h) for recursion\n    \"\"\"\n    result = []\n    \n    def dfs(node, level):\n        if not node:\n            return\n        \n        # Add new level list if needed\n        if level == len(result):\n            result.append([])\n        \n        result[level].append(node.val)\n        dfs(node.left, level + 1)\n        dfs(node.right, level + 1)\n    \n    dfs(root, 0)\n    return result\n\nprint(\"DFS approach also works\")",
          "expectedOutput": "DFS approach also works"
        }
      ]
    },
    {
      "id": 121,
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "Easy",
      "description": "Given an array prices where prices[i] is the price of a stock on the ith day, find the maximum profit you can achieve. You may complete at most one transaction.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft", "Apple"],
      "patterns": ["Dynamic Programming", "Greedy"],
      "leetcodeUrl": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
      "solutions": [
        {
          "approach": "Brute Force",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(1)",
          "bestFor": "Understanding only",
          "isOptimal": false,
          "code": "def maxProfit(prices):\n    \"\"\"\n    Brute Force: Check all buy-sell pairs\n    Time: O(n^2)\n    Space: O(1)\n    \"\"\"\n    max_profit = 0\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - prices[i]\n            max_profit = max(max_profit, profit)\n    return max_profit\n\nprint(f\"Brute force [7,1,5,3,6,4]: {maxProfit([7,1,5,3,6,4])}\")  # 5",
          "expectedOutput": "Brute force [7,1,5,3,6,4]: 5"
        },
        {
          "approach": "One Pass (Track Minimum)",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def maxProfit(prices):\n    \"\"\"\n    One Pass: Track minimum price seen so far\n    Time: O(n) - single pass\n    Space: O(1)\n    \n    Key insight: For each day, calculate profit if we sell today\n    after buying at the minimum price before today\n    \"\"\"\n    if not prices:\n        return 0\n    \n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        # Update minimum price seen\n        min_price = min(min_price, price)\n        # Calculate profit if we sell today\n        profit = price - min_price\n        max_profit = max(max_profit, profit)\n    \n    return max_profit\n\n# ======== TEST CASES ========\nprint(\"=== Best Time to Buy and Sell Stock ===\")\n\ntest_cases = [\n    ([7, 1, 5, 3, 6, 4], 5),  # Buy at 1, sell at 6\n    ([7, 6, 4, 3, 1], 0),     # No profit possible\n    ([1, 2], 1),\n    ([2, 1, 2, 1, 0, 1, 2], 2),\n]\n\nfor prices, expected in test_cases:\n    result = maxProfit(prices)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} {prices} -> {result}\")",
          "expectedOutput": "=== Best Time to Buy and Sell Stock ===\n  Y [7, 1, 5, 3, 6, 4] -> 5\n  Y [7, 6, 4, 3, 1] -> 0\n  Y [1, 2] -> 1\n  Y [2, 1, 2, 1, 0, 1, 2] -> 2"
        }
      ]
    },
    {
      "id": 124,
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "Hard",
      "description": "Given the root of a binary tree, return the maximum path sum of any non-empty path. A path can start and end at any node in the tree.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Tree", "DFS", "Dynamic Programming"],
      "leetcodeUrl": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
      "solutions": [
        {
          "approach": "DFS with Global Maximum",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root):\n    \"\"\"\n    DFS: At each node, compute max path through it\n    Time: O(n) - visit each node once\n    Space: O(h) - recursion depth\n    \n    Key insight: For each node, path can either:\n    1. Go through node (left + node + right)\n    2. Continue upward (node + max(left, right))\n    \"\"\"\n    max_sum = [float('-inf')]  # Global max\n    \n    def dfs(node):\n        if not node:\n            return 0\n        \n        # Get max sum from left and right (ignore negative paths)\n        left_max = max(0, dfs(node.left))\n        right_max = max(0, dfs(node.right))\n        \n        # Path through current node (potential answer)\n        path_through = node.val + left_max + right_max\n        max_sum[0] = max(max_sum[0], path_through)\n        \n        # Return max path that can extend upward\n        return node.val + max(left_max, right_max)\n    \n    dfs(root)\n    return max_sum[0]\n\n# ======== TEST CASES ========\nprint(\"=== Binary Tree Maximum Path Sum ===\")\n\n# Test 1: [1, 2, 3]\nroot1 = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(f\"  [1, 2, 3]: {maxPathSum(root1)}\")  # 6 (2 + 1 + 3)\n\n# Test 2: [-10, 9, 20, null, null, 15, 7]\nroot2 = TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\nprint(f\"  [-10, 9, 20, null, null, 15, 7]: {maxPathSum(root2)}\")  # 42 (15 + 20 + 7)\n\n# Test 3: Single negative\nroot3 = TreeNode(-3)\nprint(f\"  [-3]: {maxPathSum(root3)}\")  # -3",
          "expectedOutput": "=== Binary Tree Maximum Path Sum ===\n  [1, 2, 3]: 6\n  [-10, 9, 20, null, null, 15, 7]: 42\n  [-3]: -3"
        }
      ]
    },
    {
      "id": 128,
      "title": "Longest Consecutive Sequence",
      "difficulty": "Medium",
      "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. Must run in O(n) time.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Hash Set", "Union Find"],
      "leetcodeUrl": "https://leetcode.com/problems/longest-consecutive-sequence/",
      "solutions": [
        {
          "approach": "Sorting",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "def longestConsecutive(nums):\n    \"\"\"\n    Sorting: Sort and count consecutive\n    Time: O(n log n) - sorting\n    Space: O(1) or O(n) depending on sort\n    \n    Note: Does not meet O(n) requirement\n    \"\"\"\n    if not nums:\n        return 0\n    \n    nums.sort()\n    longest = 1\n    current = 1\n    \n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            continue  # Skip duplicates\n        elif nums[i] == nums[i-1] + 1:\n            current += 1\n        else:\n            longest = max(longest, current)\n            current = 1\n    \n    return max(longest, current)\n\nprint(f\"Sorting: {longestConsecutive([100,4,200,1,3,2])}\")  # 4",
          "expectedOutput": "Sorting: 4"
        },
        {
          "approach": "Hash Set",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def longestConsecutive(nums):\n    \"\"\"\n    Hash Set: Only start counting from sequence start\n    Time: O(n) - each number visited at most twice\n    Space: O(n) - hash set\n    \n    Key insight: Only start counting if num-1 doesn't exist\n    (meaning num is the start of a sequence)\n    \"\"\"\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        # Only process if this is start of sequence\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            # Count consecutive numbers\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            longest = max(longest, current_length)\n    \n    return longest\n\n# ======== TEST CASES ========\nprint(\"=== Longest Consecutive Sequence ===\")\n\ntest_cases = [\n    ([100, 4, 200, 1, 3, 2], 4),      # [1,2,3,4]\n    ([0, 3, 7, 2, 5, 8, 4, 6, 0, 1], 9),  # [0-8]\n    ([], 0),\n    ([1, 2, 0, 1], 3),  # [0,1,2] with duplicate\n]\n\nfor nums, expected in test_cases:\n    result = longestConsecutive(nums)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} {nums} -> {result}\")",
          "expectedOutput": "=== Longest Consecutive Sequence ===\n  Y [100, 4, 200, 1, 3, 2] -> 4\n  Y [0, 3, 7, 2, 5, 8, 4, 6, 0, 1] -> 9\n  Y [] -> 0\n  Y [1, 2, 0, 1] -> 3"
        }
      ]
    },
    {
      "id": 133,
      "title": "Clone Graph",
      "difficulty": "Medium",
      "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Graph", "BFS", "DFS", "Hash Map"],
      "leetcodeUrl": "https://leetcode.com/problems/clone-graph/",
      "solutions": [
        {
          "approach": "DFS with HashMap",
          "timeComplexity": "O(V + E)",
          "spaceComplexity": "O(V)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    \"\"\"\n    DFS: Clone nodes recursively with hash map\n    Time: O(V + E) - visit each node and edge once\n    Space: O(V) - hash map and recursion stack\n    \n    Key insight: Use hash map to track cloned nodes\n    \"\"\"\n    if not node:\n        return None\n    \n    cloned = {}  # old node -> new node\n    \n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n        \n        # Create clone\n        clone = Node(node.val)\n        cloned[node] = clone\n        \n        # Clone neighbors\n        for neighbor in node.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)\n\n# ======== TEST CASES ========\nprint(\"=== Clone Graph ===\")\n\n# Create graph: 1 -- 2\n#               |    |\n#               4 -- 3\nnode1 = Node(1)\nnode2 = Node(2)\nnode3 = Node(3)\nnode4 = Node(4)\nnode1.neighbors = [node2, node4]\nnode2.neighbors = [node1, node3]\nnode3.neighbors = [node2, node4]\nnode4.neighbors = [node1, node3]\n\nclone = cloneGraph(node1)\nprint(f\"  Original node 1 val: {node1.val}\")\nprint(f\"  Cloned node 1 val: {clone.val}\")\nprint(f\"  Are they same object? {clone is node1}\")\nprint(f\"  Clone neighbor vals: {[n.val for n in clone.neighbors]}\")",
          "expectedOutput": "=== Clone Graph ===\n  Original node 1 val: 1\n  Cloned node 1 val: 1\n  Are they same object? False\n  Clone neighbor vals: [2, 4]"
        },
        {
          "approach": "BFS with HashMap",
          "timeComplexity": "O(V + E)",
          "spaceComplexity": "O(V)",
          "bestFor": "Iterative approach",
          "isOptimal": true,
          "code": "from collections import deque\n\ndef cloneGraph(node):\n    \"\"\"\n    BFS: Clone nodes iteratively\n    Time: O(V + E)\n    Space: O(V)\n    \"\"\"\n    if not node:\n        return None\n    \n    cloned = {node: Node(node.val)}\n    queue = deque([node])\n    \n    while queue:\n        curr = queue.popleft()\n        \n        for neighbor in curr.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                queue.append(neighbor)\n            cloned[curr].neighbors.append(cloned[neighbor])\n    \n    return cloned[node]\n\nprint(\"BFS approach also works\")",
          "expectedOutput": "BFS approach also works"
        }
      ]
    },
    {
      "id": 139,
      "title": "Word Break",
      "difficulty": "Medium",
      "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of dictionary words.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Dynamic Programming", "Trie"],
      "leetcodeUrl": "https://leetcode.com/problems/word-break/",
      "solutions": [
        {
          "approach": "Recursion with Memoization",
          "timeComplexity": "O(n^3)",
          "spaceComplexity": "O(n)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "def wordBreak(s, wordDict):\n    \"\"\"\n    Memoization: Try each word at each position\n    Time: O(n^3) - n positions, n substrings, O(n) comparison\n    Space: O(n) - memo and recursion\n    \"\"\"\n    word_set = set(wordDict)\n    memo = {}\n    \n    def dfs(start):\n        if start == len(s):\n            return True\n        if start in memo:\n            return memo[start]\n        \n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in word_set and dfs(end):\n                memo[start] = True\n                return True\n        \n        memo[start] = False\n        return False\n    \n    return dfs(0)\n\nprint(f\"Memoization: {wordBreak('leetcode', ['leet', 'code'])}\")  # True",
          "expectedOutput": "Memoization: True"
        },
        {
          "approach": "Dynamic Programming",
          "timeComplexity": "O(n^3)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def wordBreak(s, wordDict):\n    \"\"\"\n    DP: dp[i] = can s[:i] be segmented?\n    Time: O(n^3) - n positions, check all substrings\n    Space: O(n) - dp array\n    \n    Key insight: dp[i] = True if dp[j] and s[j:i] in dict\n    \"\"\"\n    word_set = set(wordDict)\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True  # Empty string\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]\n\n# ======== TEST CASES ========\nprint(\"=== Word Break ===\")\n\ntest_cases = [\n    (\"leetcode\", [\"leet\", \"code\"], True),\n    (\"applepenapple\", [\"apple\", \"pen\"], True),\n    (\"catsandog\", [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"], False),\n]\n\nfor s, wordDict, expected in test_cases:\n    result = wordBreak(s, wordDict)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} '{s}' with {wordDict} -> {result}\")",
          "expectedOutput": "=== Word Break ===\n  Y 'leetcode' with ['leet', 'code'] -> True\n  Y 'applepenapple' with ['apple', 'pen'] -> True\n  Y 'catsandog' with ['cats', 'dog', 'sand', 'and', 'cat'] -> False"
        }
      ]
    },
    {
      "id": 141,
      "title": "Linked List Cycle",
      "difficulty": "Easy",
      "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Linked List", "Two Pointers", "Floyd's Algorithm"],
      "leetcodeUrl": "https://leetcode.com/problems/linked-list-cycle/",
      "solutions": [
        {
          "approach": "Hash Set",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef hasCycle(head):\n    \"\"\"\n    Hash Set: Track visited nodes\n    Time: O(n)\n    Space: O(n) - store all nodes\n    \"\"\"\n    seen = set()\n    curr = head\n    while curr:\n        if curr in seen:\n            return True\n        seen.add(curr)\n        curr = curr.next\n    return False\n\nprint(\"Hash set approach: O(n) space\")",
          "expectedOutput": "Hash set approach: O(n) space"
        },
        {
          "approach": "Floyd's Cycle Detection (Tortoise and Hare)",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef hasCycle(head):\n    \"\"\"\n    Floyd's Algorithm: Slow and fast pointers\n    Time: O(n) - fast catches slow in cycle\n    Space: O(1) - only two pointers\n    \n    Key insight: If cycle exists, fast will eventually meet slow\n    \"\"\"\n    if not head or not head.next:\n        return False\n    \n    slow = head\n    fast = head\n    \n    while fast and fast.next:\n        slow = slow.next       # Move 1 step\n        fast = fast.next.next  # Move 2 steps\n        \n        if slow == fast:\n            return True\n    \n    return False\n\n# ======== TEST CASES ========\nprint(\"=== Linked List Cycle ===\")\n\n# Test 1: Cycle exists [3,2,0,-4] with cycle at index 1\nnode1 = ListNode(3)\nnode2 = ListNode(2)\nnode3 = ListNode(0)\nnode4 = ListNode(-4)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node2  # Cycle\nprint(f\"  Cycle at index 1: {hasCycle(node1)}\")  # True\n\n# Test 2: No cycle [1, 2]\nnode1 = ListNode(1)\nnode2 = ListNode(2)\nnode1.next = node2\nprint(f\"  No cycle [1,2]: {hasCycle(node1)}\")  # False\n\n# Test 3: Single node, no cycle\nnode1 = ListNode(1)\nprint(f\"  Single node: {hasCycle(node1)}\")  # False",
          "expectedOutput": "=== Linked List Cycle ===\n  Cycle at index 1: True\n  No cycle [1,2]: False\n  Single node: False"
        }
      ]
    },
    {
      "id": 146,
      "title": "LRU Cache",
      "difficulty": "Medium",
      "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with get and put operations in O(1) time.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft", "Apple"],
      "patterns": ["Design", "Hash Map", "Doubly Linked List"],
      "leetcodeUrl": "https://leetcode.com/problems/lru-cache/",
      "solutions": [
        {
          "approach": "OrderedDict",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(capacity)",
          "bestFor": "Python interviews",
          "isOptimal": true,
          "code": "from collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"\n    OrderedDict: Maintains insertion order\n    Time: O(1) for get and put\n    Space: O(capacity)\n    \n    Key insight: move_to_end() maintains LRU order\n    \"\"\"\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move to end (most recently used)\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # Remove least recently used (first item)\n            self.cache.popitem(last=False)\n\n# ======== TEST CASES ========\nprint(\"=== LRU Cache ===\")\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(f\"  get(1): {cache.get(1)}\")     # 1\ncache.put(3, 3)                         # Evicts key 2\nprint(f\"  get(2): {cache.get(2)}\")     # -1 (evicted)\ncache.put(4, 4)                         # Evicts key 1\nprint(f\"  get(1): {cache.get(1)}\")     # -1 (evicted)\nprint(f\"  get(3): {cache.get(3)}\")     # 3\nprint(f\"  get(4): {cache.get(4)}\")     # 4",
          "expectedOutput": "=== LRU Cache ===\n  get(1): 1\n  get(2): -1\n  get(1): -1\n  get(3): 3\n  get(4): 4"
        },
        {
          "approach": "Hash Map + Doubly Linked List",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(capacity)",
          "bestFor": "Understanding internals",
          "isOptimal": true,
          "code": "class DLinkedNode:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    \"\"\"\n    Hash Map + Doubly Linked List\n    HashMap: O(1) lookup\n    DLL: O(1) add/remove at any position\n    \n    Key insight: Head = most recent, Tail = least recent\n    \"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}  # key -> node\n        # Dummy head and tail\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _add_node(self, node):\n        \"\"\"Add right after head (most recent)\"\"\"\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node):\n        \"\"\"Remove node from list\"\"\"\n        prev = node.prev\n        new = node.next\n        prev.next = new\n        new.prev = prev\n    \n    def _move_to_head(self, node):\n        \"\"\"Move existing node to head\"\"\"\n        self._remove_node(node)\n        self._add_node(node)\n    \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._move_to_head(node)\n        return node.val\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self._move_to_head(node)\n        else:\n            node = DLinkedNode(key, value)\n            self.cache[key] = node\n            self._add_node(node)\n            if len(self.cache) > self.capacity:\n                # Remove LRU (before tail)\n                lru = self.tail.prev\n                self._remove_node(lru)\n                del self.cache[lru.key]\n\nprint(\"Hash Map + DLL implementation\")",
          "expectedOutput": "Hash Map + DLL implementation"
        }
      ]
    },
    {
      "id": 152,
      "title": "Maximum Product Subarray",
      "difficulty": "Medium",
      "description": "Given an integer array nums, find a contiguous non-empty subarray that has the largest product, and return the product.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Dynamic Programming", "Array"],
      "leetcodeUrl": "https://leetcode.com/problems/maximum-product-subarray/",
      "solutions": [
        {
          "approach": "Track Min and Max",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def maxProduct(nums):\n    \"\"\"\n    Track both min and max at each position\n    Time: O(n) - single pass\n    Space: O(1)\n    \n    Key insight: Negative * negative = positive\n    So we need to track minimum too (might become max)\n    \"\"\"\n    if not nums:\n        return 0\n    \n    result = nums[0]\n    curr_max = nums[0]\n    curr_min = nums[0]\n    \n    for i in range(1, len(nums)):\n        num = nums[i]\n        \n        # When multiplying by negative, min and max swap\n        if num < 0:\n            curr_max, curr_min = curr_min, curr_max\n        \n        # Either extend subarray or start new\n        curr_max = max(num, curr_max * num)\n        curr_min = min(num, curr_min * num)\n        \n        result = max(result, curr_max)\n    \n    return result\n\n# ======== TEST CASES ========\nprint(\"=== Maximum Product Subarray ===\")\n\ntest_cases = [\n    ([2, 3, -2, 4], 6),      # [2,3]\n    ([-2, 0, -1], 0),         # [0]\n    ([-2, 3, -4], 24),        # [-2,3,-4]\n    ([2, -5, -2, -4, 3], 24), # [-5,-2,-4,3] or [-2,-4,3]\n]\n\nfor nums, expected in test_cases:\n    result = maxProduct(nums)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} {nums} -> {result}\")",
          "expectedOutput": "=== Maximum Product Subarray ===\n  Y [2, 3, -2, 4] -> 6\n  Y [-2, 0, -1] -> 0\n  Y [-2, 3, -4] -> 24\n  Y [2, -5, -2, -4, 3] -> 24"
        }
      ]
    },
    {
      "id": 153,
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "description": "Given the sorted rotated array nums of unique elements, return the minimum element of this array. Must run in O(log n) time.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Binary Search", "Array"],
      "leetcodeUrl": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
      "solutions": [
        {
          "approach": "Binary Search",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def findMin(nums):\n    \"\"\"\n    Binary Search: Find the rotation point\n    Time: O(log n)\n    Space: O(1)\n    \n    Key insight: Minimum is where the rotation happens\n    Compare with rightmost element to determine direction\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    # Array is not rotated\n    if nums[left] <= nums[right]:\n        return nums[left]\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # If mid > right, minimum is in right half\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        # Otherwise minimum is in left half (including mid)\n        else:\n            right = mid\n    \n    return nums[left]\n\n# ======== TEST CASES ========\nprint(\"=== Find Minimum in Rotated Sorted Array ===\")\n\ntest_cases = [\n    ([3, 4, 5, 1, 2], 1),\n    ([4, 5, 6, 7, 0, 1, 2], 0),\n    ([11, 13, 15, 17], 11),  # Not rotated\n    ([2, 1], 1),\n    ([1], 1),\n]\n\nfor nums, expected in test_cases:\n    result = findMin(nums)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} {nums} -> {result}\")",
          "expectedOutput": "=== Find Minimum in Rotated Sorted Array ===\n  Y [3, 4, 5, 1, 2] -> 1\n  Y [4, 5, 6, 7, 0, 1, 2] -> 0\n  Y [11, 13, 15, 17] -> 11\n  Y [2, 1] -> 1\n  Y [1] -> 1"
        }
      ]
    },
    {
      "id": 155,
      "title": "Min Stack",
      "difficulty": "Medium",
      "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Design", "Stack"],
      "leetcodeUrl": "https://leetcode.com/problems/min-stack/",
      "solutions": [
        {
          "approach": "Two Stacks",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class MinStack:\n    \"\"\"\n    Two Stacks: Main stack + min stack\n    Time: O(1) for all operations\n    Space: O(n)\n    \n    Key insight: Track minimum at each state\n    \"\"\"\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []  # Track min at each level\n    \n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        # Push to min_stack if empty or val <= current min\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self) -> None:\n        val = self.stack.pop()\n        # Pop from min_stack if popped value was the min\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1]\n    \n    def getMin(self) -> int:\n        return self.min_stack[-1]\n\n# ======== TEST CASES ========\nprint(\"=== Min Stack ===\")\n\nminStack = MinStack()\nminStack.push(-2)\nminStack.push(0)\nminStack.push(-3)\nprint(f\"  getMin(): {minStack.getMin()}\")  # -3\nminStack.pop()\nprint(f\"  top(): {minStack.top()}\")        # 0\nprint(f\"  getMin(): {minStack.getMin()}\")  # -2",
          "expectedOutput": "=== Min Stack ===\n  getMin(): -3\n  top(): 0\n  getMin(): -2"
        },
        {
          "approach": "Single Stack with Pairs",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(n)",
          "bestFor": "Alternative",
          "isOptimal": true,
          "code": "class MinStack:\n    \"\"\"\n    Single Stack: Store (value, min_so_far) pairs\n    Time: O(1)\n    Space: O(n)\n    \"\"\"\n    def __init__(self):\n        self.stack = []  # [(value, min_so_far), ...]\n    \n    def push(self, val: int) -> None:\n        current_min = min(val, self.stack[-1][1]) if self.stack else val\n        self.stack.append((val, current_min))\n    \n    def pop(self) -> None:\n        self.stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1][0]\n    \n    def getMin(self) -> int:\n        return self.stack[-1][1]\n\nprint(\"Single stack with pairs also works\")",
          "expectedOutput": "Single stack with pairs also works"
        }
      ]
    },
    {
      "id": 169,
      "title": "Majority Element",
      "difficulty": "Easy",
      "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than n/2 times.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Array", "Hash Map", "Boyer-Moore Voting"],
      "leetcodeUrl": "https://leetcode.com/problems/majority-element/",
      "solutions": [
        {
          "approach": "Hash Map",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "from collections import Counter\n\ndef majorityElement(nums):\n    \"\"\"\n    Hash Map: Count occurrences\n    Time: O(n)\n    Space: O(n)\n    \"\"\"\n    counts = Counter(nums)\n    return max(counts.keys(), key=counts.get)\n\nprint(f\"Hash Map: {majorityElement([3,2,3])}\")  # 3",
          "expectedOutput": "Hash Map: 3"
        },
        {
          "approach": "Boyer-Moore Voting Algorithm",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def majorityElement(nums):\n    \"\"\"\n    Boyer-Moore Voting: Cancel out different elements\n    Time: O(n) - single pass\n    Space: O(1)\n    \n    Key insight: Majority element survives cancellation\n    Because it appears > n/2 times\n    \"\"\"\n    candidate = None\n    count = 0\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    \n    return candidate\n\n# ======== TEST CASES ========\nprint(\"=== Majority Element ===\")\n\ntest_cases = [\n    ([3, 2, 3], 3),\n    ([2, 2, 1, 1, 1, 2, 2], 2),\n    ([1], 1),\n    ([1, 1, 1, 2, 2], 1),\n]\n\nfor nums, expected in test_cases:\n    result = majorityElement(nums)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} {nums} -> {result}\")",
          "expectedOutput": "=== Majority Element ===\n  Y [3, 2, 3] -> 3\n  Y [2, 2, 1, 1, 1, 2, 2] -> 2\n  Y [1] -> 1\n  Y [1, 1, 1, 2, 2] -> 1"
        }
      ]
    },
    {
      "id": 198,
      "title": "House Robber",
      "difficulty": "Medium",
      "description": "Given an array representing the amount of money of each house, return the maximum amount you can rob without alerting the police (no two adjacent houses).",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Dynamic Programming"],
      "leetcodeUrl": "https://leetcode.com/problems/house-robber/",
      "solutions": [
        {
          "approach": "DP with Array",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Understanding",
          "isOptimal": false,
          "code": "def rob(nums):\n    \"\"\"\n    DP Array: dp[i] = max money robbing houses 0..i\n    Time: O(n)\n    Space: O(n)\n    \n    Recurrence: dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]\n\nprint(f\"DP Array: {rob([1,2,3,1])}\")  # 4",
          "expectedOutput": "DP Array: 4"
        },
        {
          "approach": "DP Optimized Space",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def rob(nums):\n    \"\"\"\n    DP Optimized: Only track last two values\n    Time: O(n)\n    Space: O(1)\n    \n    Key insight: Only need dp[i-1] and dp[i-2] to compute dp[i]\n    \"\"\"\n    if not nums:\n        return 0\n    \n    prev2 = 0  # dp[i-2]\n    prev1 = 0  # dp[i-1]\n    \n    for num in nums:\n        current = max(prev1, prev2 + num)\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n# ======== TEST CASES ========\nprint(\"=== House Robber ===\")\n\ntest_cases = [\n    ([1, 2, 3, 1], 4),       # Rob house 0 and 2\n    ([2, 7, 9, 3, 1], 12),   # Rob house 0, 2, 4\n    ([2, 1, 1, 2], 4),       # Rob house 0 and 3\n    ([], 0),\n    ([5], 5),\n]\n\nfor nums, expected in test_cases:\n    result = rob(nums)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} {nums} -> {result}\")",
          "expectedOutput": "=== House Robber ===\n  Y [1, 2, 3, 1] -> 4\n  Y [2, 7, 9, 3, 1] -> 12\n  Y [2, 1, 1, 2] -> 4\n  Y [] -> 0\n  Y [5] -> 5"
        }
      ]
    },
    {
      "id": 200,
      "title": "Number of Islands",
      "difficulty": "Medium",
      "description": "Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft", "Apple"],
      "patterns": ["DFS", "BFS", "Union Find"],
      "leetcodeUrl": "https://leetcode.com/problems/number-of-islands/",
      "solutions": [
        {
          "approach": "DFS",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "def numIslands(grid):\n    \"\"\"\n    DFS: Flood fill to mark visited land\n    Time: O(m * n) - visit each cell once\n    Space: O(m * n) - recursion stack in worst case\n    \n    Key insight: Each DFS from unvisited land discovers one island\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def dfs(r, c):\n        # Boundary and water check\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':\n            return\n        \n        # Mark as visited\n        grid[r][c] = '0'\n        \n        # Visit all 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                islands += 1\n                dfs(r, c)\n    \n    return islands\n\n# ======== TEST CASES ========\nprint(\"=== Number of Islands ===\")\n\ngrid1 = [\n    [\"1\",\"1\",\"1\",\"1\",\"0\"],\n    [\"1\",\"1\",\"0\",\"1\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nprint(f\"  Grid 1: {numIslands([row[:] for row in grid1])}\")  # 1\n\ngrid2 = [\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nprint(f\"  Grid 2: {numIslands([row[:] for row in grid2])}\")  # 3",
          "expectedOutput": "=== Number of Islands ===\n  Grid 1: 1\n  Grid 2: 3"
        },
        {
          "approach": "BFS",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(min(m, n))",
          "bestFor": "Avoid stack overflow",
          "isOptimal": true,
          "code": "from collections import deque\n\ndef numIslands(grid):\n    \"\"\"\n    BFS: Level-by-level exploration\n    Time: O(m * n)\n    Space: O(min(m, n)) - queue size\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def bfs(start_r, start_c):\n        queue = deque([(start_r, start_c)])\n        grid[start_r][start_c] = '0'\n        \n        while queue:\n            r, c = queue.popleft()\n            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':\n                    grid[nr][nc] = '0'\n                    queue.append((nr, nc))\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                islands += 1\n                bfs(r, c)\n    \n    return islands\n\nprint(\"BFS approach also works\")",
          "expectedOutput": "BFS approach also works"
        }
      ]
    },
    {
      "id": 206,
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft", "Apple"],
      "patterns": ["Linked List", "Recursion"],
      "leetcodeUrl": "https://leetcode.com/problems/reverse-linked-list/",
      "solutions": [
        {
          "approach": "Iterative",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseList(head):\n    \"\"\"\n    Iterative: Reverse pointers one by one\n    Time: O(n) - single pass\n    Space: O(1) - only pointers\n    \n    Key insight: Track prev, curr, next pointers\n    \"\"\"\n    prev = None\n    curr = head\n    \n    while curr:\n        next_temp = curr.next  # Save next\n        curr.next = prev       # Reverse pointer\n        prev = curr            # Move prev forward\n        curr = next_temp       # Move curr forward\n    \n    return prev\n\n# Helper functions\ndef create_list(arr):\n    dummy = ListNode(0)\n    curr = dummy\n    for val in arr:\n        curr.next = ListNode(val)\n        curr = curr.next\n    return dummy.next\n\ndef list_to_arr(node):\n    arr = []\n    while node:\n        arr.append(node.val)\n        node = node.next\n    return arr\n\n# ======== TEST CASES ========\nprint(\"=== Reverse Linked List ===\")\n\ntest_cases = [\n    [1, 2, 3, 4, 5],\n    [1, 2],\n    [],\n]\n\nfor arr in test_cases:\n    head = create_list(arr)\n    result = reverseList(head)\n    result_arr = list_to_arr(result)\n    print(f\"  {arr} -> {result_arr}\")",
          "expectedOutput": "=== Reverse Linked List ===\n  [1, 2, 3, 4, 5] -> [5, 4, 3, 2, 1]\n  [1, 2] -> [2, 1]\n  [] -> []"
        },
        {
          "approach": "Recursive",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "bestFor": "Understanding recursion",
          "isOptimal": false,
          "code": "def reverseList(head):\n    \"\"\"\n    Recursive: Reverse from end to beginning\n    Time: O(n)\n    Space: O(n) - recursion stack\n    \n    Key insight: Recursively reverse rest, then fix current\n    \"\"\"\n    # Base case: empty or single node\n    if not head or not head.next:\n        return head\n    \n    # Recursively reverse the rest\n    new_head = reverseList(head.next)\n    \n    # Fix current node\n    head.next.next = head\n    head.next = None\n    \n    return new_head\n\nprint(\"Recursive approach uses O(n) space\")",
          "expectedOutput": "Recursive approach uses O(n) space"
        }
      ]
    },
    {
      "id": 207,
      "title": "Course Schedule",
      "difficulty": "Medium",
      "description": "Given numCourses and prerequisites array, return true if you can finish all courses. Detect if there's a cycle in the course dependency graph.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Graph", "Topological Sort", "DFS", "BFS"],
      "leetcodeUrl": "https://leetcode.com/problems/course-schedule/",
      "solutions": [
        {
          "approach": "DFS Cycle Detection",
          "timeComplexity": "O(V + E)",
          "spaceComplexity": "O(V + E)",
          "bestFor": "Understanding",
          "isOptimal": true,
          "code": "def canFinish(numCourses, prerequisites):\n    \"\"\"\n    DFS: Detect cycle in directed graph\n    Time: O(V + E) - visit each node and edge once\n    Space: O(V + E) - adjacency list and recursion\n    \n    Key insight: Use 3 states: unvisited, visiting, visited\n    Cycle exists if we visit a node that's currently being visited\n    \"\"\"\n    # Build adjacency list\n    graph = [[] for _ in range(numCourses)]\n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n    \n    # 0: unvisited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    \n    def has_cycle(course):\n        if state[course] == 1:  # Currently visiting - cycle!\n            return True\n        if state[course] == 2:  # Already processed\n            return False\n        \n        state[course] = 1  # Mark as visiting\n        \n        for next_course in graph[course]:\n            if has_cycle(next_course):\n                return True\n        \n        state[course] = 2  # Mark as visited\n        return False\n    \n    for course in range(numCourses):\n        if has_cycle(course):\n            return False\n    \n    return True\n\n# ======== TEST CASES ========\nprint(\"=== Course Schedule ===\")\n\ntest_cases = [\n    (2, [[1, 0]], True),           # 0 -> 1, no cycle\n    (2, [[1, 0], [0, 1]], False),  # 0 -> 1 -> 0, cycle\n    (3, [[1, 0], [2, 1]], True),   # 0 -> 1 -> 2, no cycle\n    (1, [], True),                  # Single course\n]\n\nfor n, prereqs, expected in test_cases:\n    result = canFinish(n, prereqs)\n    status = \"Y\" if result == expected else \"X\"\n    print(f\"  {status} courses={n}, prereqs={prereqs} -> {result}\")",
          "expectedOutput": "=== Course Schedule ===\n  Y courses=2, prereqs=[[1, 0]] -> True\n  Y courses=2, prereqs=[[1, 0], [0, 1]] -> False\n  Y courses=3, prereqs=[[1, 0], [2, 1]] -> True\n  Y courses=1, prereqs=[] -> True"
        },
        {
          "approach": "BFS (Kahn's Algorithm)",
          "timeComplexity": "O(V + E)",
          "spaceComplexity": "O(V + E)",
          "bestFor": "Interviews - Topological Sort",
          "isOptimal": true,
          "code": "from collections import deque\n\ndef canFinish(numCourses, prerequisites):\n    \"\"\"\n    Kahn's Algorithm: BFS-based topological sort\n    Time: O(V + E)\n    Space: O(V + E)\n    \n    Key insight: Start from nodes with no incoming edges\n    If we can process all nodes, no cycle exists\n    \"\"\"\n    # Build graph and count incoming edges\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    # Start with courses that have no prerequisites\n    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    completed = 0\n    \n    while queue:\n        course = queue.popleft()\n        completed += 1\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    return completed == numCourses\n\nprint(\"Kahn's algorithm (BFS) also works\")",
          "expectedOutput": "Kahn's algorithm (BFS) also works"
        }
      ]
    },
    {
      "id": 208,
      "title": "Implement Trie (Prefix Tree)",
      "difficulty": "Medium",
      "description": "Implement a trie with insert, search, and startsWith methods.",
      "companies": ["Amazon", "Google", "Meta", "Microsoft"],
      "patterns": ["Design", "Trie"],
      "leetcodeUrl": "https://leetcode.com/problems/implement-trie-prefix-tree/",
      "solutions": [
        {
          "approach": "Hash Map Children",
          "timeComplexity": "O(m)",
          "spaceComplexity": "O(m)",
          "bestFor": "Interviews",
          "isOptimal": true,
          "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}  # char -> TrieNode\n        self.is_end = False\n\nclass Trie:\n    \"\"\"\n    Trie: Prefix tree for efficient string operations\n    Time: O(m) for all operations (m = word length)\n    Space: O(m) per word in worst case\n    \n    Key insight: Each node represents a character,\n    path from root to node represents a prefix\n    \"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        \"\"\"Insert word into trie\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        \"\"\"Returns True if word is in trie\"\"\"\n        node = self._find_prefix(word)\n        return node is not None and node.is_end\n    \n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"Returns True if any word starts with prefix\"\"\"\n        return self._find_prefix(prefix) is not None\n    \n    def _find_prefix(self, prefix: str):\n        \"\"\"Helper to find node at end of prefix\"\"\"\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return None\n            node = node.children[char]\n        return node\n\n# ======== TEST CASES ========\nprint(\"=== Implement Trie ===\")\n\ntrie = Trie()\ntrie.insert(\"apple\")\nprint(f\"  search('apple'): {trie.search('apple')}\")     # True\nprint(f\"  search('app'): {trie.search('app')}\")         # False\nprint(f\"  startsWith('app'): {trie.startsWith('app')}\") # True\ntrie.insert(\"app\")\nprint(f\"  search('app') after insert: {trie.search('app')}\")  # True",
          "expectedOutput": "=== Implement Trie ===\n  search('apple'): True\n  search('app'): False\n  startsWith('app'): True\n  search('app') after insert: True"
        },
        {
          "approach": "Array Children (26 letters)",
          "timeComplexity": "O(m)",
          "spaceComplexity": "O(m * 26)",
          "bestFor": "Fixed alphabet",
          "isOptimal": false,
          "code": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26  # a-z\n        self.is_end = False\n\nclass Trie:\n    \"\"\"\n    Array-based Trie: Fixed size children array\n    Time: O(m)\n    Space: O(m * 26) - more space but O(1) child lookup\n    \n    Better when alphabet is small and fixed\n    \"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not node.children[index]:\n                node.children[index] = TrieNode()\n            node = node.children[index]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        node = self._find_prefix(word)\n        return node is not None and node.is_end\n    \n    def startsWith(self, prefix: str) -> bool:\n        return self._find_prefix(prefix) is not None\n    \n    def _find_prefix(self, prefix: str):\n        node = self.root\n        for char in prefix:\n            index = ord(char) - ord('a')\n            if not node.children[index]:\n                return None\n            node = node.children[index]\n        return node\n\nprint(\"Array-based trie for lowercase letters\")",
          "expectedOutput": "Array-based trie for lowercase letters"
        }
      ]
    }
  ]
}
